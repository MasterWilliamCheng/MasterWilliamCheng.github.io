在我们的实际开发应用中，缓存机制的广泛存在，大大的提高了系统对数据库的请求承受阈值，但是在一些特定的场景下，需要去了解它可能出现的问题和对应的解决方案，才能更好的增加我们系统的健壮性


**1.缓存穿透**

问题场景

* 在一般的查询场景下，当一次查询从缓存中查询不到对应的信息，那么会继续去访问数据库进行查询，这种过程被称为缓存穿透。看似正常的操作，实际上，当有人恶意的去使用根本不存在的数据去频繁访问服务器，可能就会造成系统的瘫痪。

解决方案
* bloom filter(布隆过滤器):是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。在某些查询中，可以将所有可能的查询条件放入这个集合，在查询之前使用这个集合对查询条件进行过滤，就可以避免缓存穿透的问题。
* 空值缓存：在第一次查询为空值之后，将这个查询条件key存入缓存中，缓存时间设置为较短时间，这样可以应对一些短时间内大量重复查询的情况。

**2.缓存雪崩**

问题场景

* 我们在使用例如Redis来进行缓存操作的时候，一般会给缓存设置一个过期时间，但是对于大量缓存过期时间相同的系统来说，可能会因为某个时间段缓存同时失效而造成所有本应该由缓存来接受的请求直接请求到数据库，造成数据库崩溃。当发生雪崩的时候,没有一片雪花觉得是自己的责任。

解决方案
* 交叉失效时间：在设置缓存时间的时候，我们可以在一段合理的范围时间内，随机的去设置这些缓存的过期时间，避免同一过期时间

**3.缓存击穿**

问题场景

* 缓存击穿是缓存雪崩的一个特例，某个单独的热点的缓存因为过期时间导致失效，那么同样会有大量的请求去访问数据库导致崩溃。与缓存雪崩不同的是，缓存击穿更像是某一热度点的缓存雪崩。

解决方案
* 二级缓存：对于那些热度高的数据设置二级缓存，并且错开和一级缓存的失效时间，使请求不会同时穿透两层缓存去访问数据库
