最近在研究mysql中事务和锁方面的问题，总结了一些点，方便温故知新

### **事务**
**1. ACID四大特性**

**Atomicity：原子性**
事务中的操作要么全部成功要么全部失败

**Consistency：一致性**
一个事务在执行前后，数据库都必须保持一致性，数据库只包含成功提交事务的结果

**Isolation：隔离性**
事务的执行是相互隔离的，不被干扰的

**Durability：持久性**
事务提交后，对数据的修改必须是永久保存的

**2. 隔离级别**

**未提交读（READ UNCOMMITTED）**
事务可以读取其他未提交事务中修改的数据，会发生脏读，不可重复读，幻读

**已提交读（READ COMMITTED）**
事务只能读取其他已提交事务修改的数据，可以解决脏读（读取的数据是别的未提交事务修改的数据）

**可重复读（REPEATABLE READ）**
在事务开启时，不再允许修改操作，一个事务多次读取同一数据得到的结果是一致的，可以解决不可重复读（一个事务进行2次查询，中间有别的事务进行了修改操作，导致两次查询的结果不同）

**可串行化（SERIALIZABLE）**
事务串行执行，不能并发执行，可以解决幻读（一个事务进行2次查询，中间有别的事务进行了新增或删除操作，导致得到了不同条数的数据）

### **锁**
**共享锁（读锁）**  
允许多个事务共享一把锁，但是对于加锁的数据只能读取，不能进行UPDATE DETELE等操作
lock in share mode可以添加共享锁

**排他锁（写锁）**  
只有一个事务能拿到排他锁，其他事务不能获取到锁，会阻塞直到持有锁的事务释放锁或者等待超时，不能与其他锁共存
InnoDB会对update，insert，delete语句自动加排它锁
select ... for update也会添加排他锁
其他事务可以正常执行select语句，因为select不涉及加锁（有些文章模糊了这块的概念，强调排他锁事务未提交时，其他事务不能对锁住的数据进行任何操作，我在实验过后发现不加for update的查询操作是可以执行的）

**意向共享锁/意向排他锁**
在事务获取共享锁或排他锁之前，会对整张表先加锁，意向锁存在的意义是支持行锁和表锁共存

### **锁算法**
**Record Lock（记录锁）**
对记录上的索引加锁，可以理解为行锁

**Gap Lock（间隙锁）**
间隙锁，只对索引的间隙加锁，但是不包括索引本身，只有RR隔离级别以上才支持间隙锁

**Next-Key Lock（临键锁）**
Record Lock+Gap Lock，不仅对索引加锁，也对索引的间隙加锁（左开右闭），InnoDB利用Next-Key Lock来解决幻读问题

（未完待续）
