## MVCC
顺便聊聊MVCC（多版本并发控制）。在mysql中，RC（已提交读）和RR（可重复读）隔离级别下，借助MVCC机制，可以解决查询时不同事务间的并发读写问题。

### 系统版本号 ###

系统里维护一个系统版本号，这个版本号在每次创建一个事务时就会自增。每个事务会维护一个事务版本号transaction id（以下简称事务id），这个版本号就是取自创建事务时的系统版本号。

### 版本链 ###

每行数据会维护2个虚拟列，一个是版本号TRX_ID，每次事务创建或者更新某个行数据的时候，就会把事务id赋值给该行的TRX_ID，代表这个版本的行数据是我这个事务修改的;一个是回滚指针ROLL_PTR，指向前一次的版本，所有历史版本的记录都会存在undo log里（相关log的概念后面会提到）。**注意，这里仅仅是事务修改行数据就会对TRX_ID赋值，而不是要提交事务才执行操作。我们需要搞清楚一个概念，所谓的版本，就是每次对行数据进行修改，mysql都会新增一个修改后的记录版本，然后用ROLL_PTR指向上一个版本**。所以，在mysql中会有多个不同版本的行数据，因为回滚指针的存在形成一个版本链。

![3325576781-60781adee8fa9_fix732](https://user-images.githubusercontent.com/31581862/114859808-d0d82b00-9e1d-11eb-9633-8217799a440c.png)

### readview ###

一个事务在进行查询时，会创建一个快照readview（**RC和RR不同，RR隔离级别会在事务第一次查询时生成一个快照，事务的后续查询都使用这个快照，RC级别则是事务每次查询都会生成快照**），它会存储系统中其他所有未提交活跃事务id的集合m_ids。\
ps：begin/start transaction命令并不是⼀个事务的起点，在执⾏到它们之后的第⼀个操作InnoDB表的语句（第⼀个快照读语句），事务才真正启动。如果你想要⻢上启动⼀个事务，可以使⽤start transaction with consistent snapshot这个命令。另外，更新数据都是先读后写的，⽽这个读，只能读当前的值，称为“当前读”（currentread）

那么mysql是怎么利用上述的构件去实现MVCC呢？大概有以下四种情况：

1.被访问行数据版本的TRX_ID如果小于m_ids中最小的事务id m_up_limit_id，则创建这个版本数据的事务是在当前事务创建readview前就提交了的，所以可以被当前事务访问

2.被访问行数据版本的TRX_ID如果大于m_ids中最大的事务id m_low_limit_id，则创建这个版本数据的事务是在当前事务创建readview后才开启，所以不可以被当前事务访问

3.被访问行数据版本的TRX_ID如果介于m_ids中最小和最大事务id之间，判断一下是否存在于m_ids中。如果存在，则说明创建这个版本数据的事务在当前事务创建readview时仍然活跃，事务还未提交，所以不可以被当前事务访问；反之，则这个版本数据的事务是在当前事务创建readview前就提交了的，所以可以被当前事务访问。

顺便提一下，有两点需要注意：

1.事务访问仅仅是针对单个版本而言的，行数据版本不能被当前事务访问并不意味着行数据之前的版本不能被访问，因为之前版本的事务id可能是满足被访问的条件的

2.当前事务id等于行数据版本的事务id的时候，肯定可以被当前事务访问，因为该版本就是当前事务创建的

3.MVCC实现了快照读，间隙锁+行锁实现了当前读
